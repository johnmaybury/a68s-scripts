# ppc.awk: Post-process C source generated from A68S sources by p2c

BEGIN \
{
    FALSE           = 0;
    TRUE            = 1;

    seenInclude     = FALSE;
    seenENEW        = FALSE;
    emitAlfUsesChar = FALSE;

    # command line can specify:
    #
    #    -v EXTERN=N
    #          Extern is defined to be nothing
    #    -v EXTERN=Y
    #          Extern is defined to be extern
    #    -v RC=p2crcFilePath
    #          p2crcFilePath is the path of a p2crc file generated by ppp.awk
    #          it will be used to generate code to open the files
    #    -v ENEW=N
    #          No "ENEW" processing
    #    -v ENEW=Y
    #          Process ENEW - this is the default
    #    -v RC=path-of-p2crc-file
    #    -v CYB=N
    #          do not handle the missing registers enum - this is the default
    #    -v CYB=Y
    #          handle the missing registers enum - for cybcod


    printf( "#define ASPTR(x)               ( (void *) ( x ) )\n"           );
    printf( "#define EDISPOSE(p,s)          free( (void *) ( p ) )\n"       );
    printf( "#define ENEW(s)                ( (void *) malloc( s ) )\n"     );
    printf( "#define GETADDRE(x)            ( (A68INT) ( (void *)(x) ) )\n" );
    printf( "#define INCPTR(x,y)            ( (void *) ( (x) + (y) ) )\n"   );
    printf( "#define CTIME(bfr,len,u1,u2)   CTIME1(bfr,len)\n"            );

    printf( "enum { TKTAG, TKBOLD, TKDENOT, TKSYMBOL };\n"                  );

    if( EXTERN == "N" )
    {
        printf( "#define Extern      \n"                              );
    }
    else
    {
        printf( "#define Extern extern\n"                             );
    } # if extern == "N";;

    if( RC != "" )
    {
        # have a p2crc file
        while( ( ioStat = getline rcLine < RC ) > 0 )
        {
            sub( /^ */, "", rcLine );
            sub( / *$/, "", rcLine );
            if( toupper( rcLine ) ~ /BUFFEREDFILE/ )
            {
                # have a file definition
                fName  = "?";
                fIndex = -1;
                fMode  = "?";
                sub( /#/,                " ", rcLine );
                sub( /^[a-zA-Z0-9_]* */, "",  rcLine );
                fName = rcLine;
                sub( / .*$/,             "",  fName  );
                sub( /^[a-zA-Z0-9_]* */, "",  rcLine );
                # allow for partial definitions
                if( fName in files )
                {
                    fIndex = files[ fName ];
                } # if fName in files
                if( fName in ioMode )
                {
                    fMode  = ioMode[ fName ];
                } # if fName in ioMode
                if( fName in isText )
                {
                    fType  = ( isText[ fName ] ? "text" : "" );
                } # if fName in isText
                while( rcLine != "" )
                {
                    if(      rcLine ~ /^index:/ )
                    {
                        sub( /^index: */, "", rcLine );
                        fIndex = rcLine;
                        sub( /  *.*$/,    "", fIndex );
                        sub( /^[^ ]* */,  "", rcLine );
                    }
                    else if( rcLine ~ /^mode:/ )
                    {
                        sub( /^mode: */,  "", rcLine );
                        fMode = rcLine;
                        sub( /  *.*$/,    "", fMode  );
                        sub( /^[^ ]* */,  "", rcLine );
                    }
                    else if( rcLine ~ /^type:/ )
                    {
                        sub( /^type: */,  "", rcLine );
                        fType = rcLine;
                        sub( /  *.*$/,    "", fType  );
                        sub( /^[^ ]* */,  "", rcLine );
                    }
                    else
                    {
                        # unexpected token
                        printf( "\n**** %s: Unexpected file options: %s\n",
                                RC, rcLine );
                        rcLine = "";
                    } # if various tokens;;
                } # while rcLine != ""
                files[  fName ] = fIndex;
                ioMode[ fName ] = fMode;
                isText[ fName ] = fType == "text";
                printf( "// FILE %s %d %s | %s\n",
                        fName, fIndex, fMode, rcLine );
            } # if toupper( rcLine ) ~ /BUFFEREDFILE/
        } # while ( ioStat = getline rcLine < RC ) > 0
        if( ioStat < 0 )
        {
            # I/O error
            printf( "\n**** I/O error on %s\n", RC );
        } # if ioStat > 0

    } # if RC != ""
    
} # BEGIN

/^ *struct *MD *MDSTRFMD *; *$/      { $0 = "  union MD * MDSTRFMD;";      }

# the following is for when identifiers are not truncated to 8 characters:
/^ *struct *LEXEME *MDSTRFLEX *; *$/ { $0 = "  union LEXEME * MDSTRFLEX;"; }

# the following is for when identifiers are     truncated to 8 characters:
/^ *struct *LEXEME *MDSTRFLE *; *$/  { $0 = "  union LEXEME * MDSTRFLE;"; }

# remove any extern or static definitions for GETADDRE
/^ *([Ss]tatic|[Ee]xtern)  *[a-zA-Z0-9_]* *GETADDRE *[(]/ \
{
    $0 = "// " $0;
} # static/extern declaration of GETADDRE

# replace any extern or static definitions for SWAPF with a macro
/^ *([Ss]tatic|[Ee]xtern)  *[a-zA-Z0-9_]* *SWAPF *[(]/ \
{
    $0 = "#define SWAPF(f1,f2) { FILE * t = f1; f1 = f2; f2 = t; } // " $0;
} # static/extern declaration of SWAPF

# if getc is used on a file, assume it is text
/getc *[(]/ \
{
    fName = $0;
    gsub( /@/,         "",  fName );
    sub(  /getc *[(]/, "@", fName );
    sub(  /^[^@]*@/,   "",  fName );
    sub(  / *[)].*$/,  "",  fName );
    isText[ fName ] = TRUE;
} # getc used on a file


# make all procedures externally accessible
/^ *(Local|Static)  *[a-zA-Z0-9_]* [ *]*[a-zA-Z0-9_]* *[(]/ \
{
    $1 = "";
    sub( /^ */, "", $0 );
} # static or local function definition

# make all files externally accessible
/^ *(Local|Static)  *FILE[ *][ *]*[a-zA-Z0-9_]*/ \
{
    $1 = "Extern";
} # static or local file definition

# make all file-buffers externally accessible
/^ *FILEBUF[(][ a-zA-Z0-9_]*,Static/ \
{
    sub( /,Static,/, ",Extern," );
} # static file-buffer

# p2c sometimes generates "rewind(NULL);" - remove it
/^ *rewind *[(] *NULL *[)] *; *$/ \
{
    $0 = "// rewind(NULL); removed";
} # rewind(NULL);

# INITIO does rewind(LSTFILE) - remove it as it is now called twice
/^ *rewind *[(] *LSTFILE *[)] *; *$/ \
{
    $0 = "// " $0;
} # rewind(LSTFILE);

# convert "file = NULL" to code to open the file
/^ *[a-zA-Z0-9_]+ *= *NULL/ \
{
    if( $1 in files )
    {
        # have a file - assume it should be opened
        sub( / NULL/,
             sprintf( " openFile( argc, argv, %d, \"%s%s\" )",
                      files[    $1 ],
                      ioMode[   $1 ],
                      ( isText[ $1 ] ? "" : "b" ) ),
             $0 );
    } # if $1 in files
} # file = NULL

# ignore "file = tmpfile"
/^ *[]a-zA-Z0-9_[]+ *= *tmpfile *[(]/ \
{
    if( $1 in files || $1 ~ /[[]/ )
    {
        # have a file
        $1 = "// ignore> " $1;
    } # if $1 in files || $1 ~ /[[]/
} # file = tmpfile()

# closeing a file
/^ *fclose *[(]/ \
{
    sub( /fclose/, "closeFile", $0 );
} # /^ *fclose *[(]/

# convert ENEW calls to assignments, the first parameter may have been
# quoted by ppp.awk, to stop p2c deleting it
/^ *ENEW *[(]/ \
{
    if( ENEW != "N" )
    {
        line = $0;
        sub( /ENEW *[(]/, "",         line );
        sub( /"/,         "",         line ); # ppp.awk quotes it using ''
        sub( /"/,         "",         line ); # but (of course) p2c generates
        sub( /,/,         " = ENEW(", line ); # C-strings
        $0 = line;
    } # if ENEW != "N"
} # ENEW call

# convert Malloc(x) to PNEW(x) if ENEW_LENGTH was used in the program
/[^A-Za-z0-9_]Malloc *[(]/ \
{
    if( seenENEW )
    {
        # ENEW_LENGTH is defined
        gsub( /Malloc *[(]/, "PNEW(", $0 );
    } # if seenENEW
} # Malloc(x)

# define the padding needed to align a double after an ADDRINT
/^# *define  *CONST_SZREAL/ \
{
    printf( "#define CONST_PAD_ADDR2REAL ( CONST_SZREAL - CONST_SZINT )\n" );
} # #define CONST_SZREAL

# attempt to handle real alignment
/CONST_SZADDR *[+] *CONST_SZREAL/ \
{
    gsub( /CONST_SZADDR *[+] *CONST_SZREAL/,
          "CONST_SZADDR + CONST_PAD_ADDR2REAL + CONST_SZREAL",
          $0 );
} # real alignment needed ?

# change prelude parameterless procedures to be non-Pascal
# avoids assertion-failure/null-pointer de-references
# random is the only affected procedure
/^ *DEFSTID1 *[(] *"RANDOM *" *,/ \
{
    sub( /, *PASC *[)]/, ", /*PASC*/PROC)", $0 );
} # random PASC->PROC

# define the operators and registers enums that p2c has omitted,
# - if we are processing cybcod
/^ *void  *ICODE *[(]/ \
{
    if( CYB == "Y" )
    {
        # we are processing the cybcod source
        printf( "#define PLUS    1\n" );
        printf( "#define MINUS   2\n" );
        printf( "#define TIMES   3\n" );
        printf( "#define OVER    4\n" );
        printf( "#define COMMA   5\n" );
        printf( "#define MISSING 6\n" );
        printf( "#define B       1\n" );
        printf( "#define A_      2\n" );
        printf( "#define X       3\n" );
        printf( "#define KK      4\n" );
        printf( "#define STAR    5\n" );
    } # if CYB == "Y"
} # start of ICODE

# undefine the registers enum that p2c has omitted, if we are processing cybcod
/^ *void  *OCODE *[(]/ \
{
    if( CYB == "Y" )
    {
        # we are processing the cybcod source
        printf( "#undef  PLUS    1\n" );
        printf( "#undef  MINUS   2\n" );
        printf( "#undef  TIMES   3\n" );
        printf( "#undef  OVER    4\n" );
        printf( "#undef  COMMA   5\n" );
        printf( "#undef  MISSING 6\n" );
        printf( "#undef  B       1\n" );
        printf( "#undef  A       2\n" );
        printf( "#undef  X       3\n" );
        printf( "#undef  KK      4\n" );
        printf( "#undef  STAR    5\n" );
    } # if CYB == "Y"
} # start of OCODE

# correct calls to EMITALF for the PERQ cide generator
/^ *void  *EMITALF *[(] *[Cc]har/ \
{
    # will need to fix EMITALF calls
    emitAlfUsesChar = TRUE;
} # EMITALF taks a Char parameter

# correct calls to EMITALF for the PERQ cide generator
/^ *EMITALF *[(]/ \
{
    if( emitAlfUsesChar )
    {
        # need to fix EMITALF calls
        sub( /[)]/, ") )",             $0 );
        sub( /[(]/, "( (Char *) \\&(", $0 );
    } # if emitAlfUsesChar
} # call to EMITALF

{ print; }

/^ *# *include / \
{
    # #include - assume it includes p2c.h
    # if it is the first include, define openFile, etc.

    if( ! seenInclude )
    {
        # this is the first include
        printf( "extern FILE * openFile"                                     \
                "( int argc, char ** argv, int pos, char * mode );\n"        );
        printf( "extern void closeFile( FILE * f );\n"                       );
        # the liba68s MOD routine has a unused "statlink" pointer parameter
        # and MOD(statline,b,a) does a MOD b
        # so we need to add a dummy parameter and reverse the parameters
        #  so we can use it for Pascal mod operations
        printf( "#define PMOD(y,x) MOD(NULL,x,y)\n"                      );
        seenInclude = TRUE;
    } # if ! seenInclude

} # /^ *# *include /

/[^A-Za-z0-9_]ENEW_LENGTH/ \
{
    # line contains ENEW_LENGTH
    # if it is the first occurance, it must be the declaration
    # follow it with the definitions of PNEW

    if( ! seenENEW && ENEW != "N" )
    {
        # this is the first occurance and we must process ENEW
        printf( "void * PNEW( A68INT len )\n"                           );
        printf( "{\n"                                                        );
        printf( "    void * result;\n"                                       );
        printf( "    if( ENEW_LENGTH < 0 )\n"                                );
        printf( "    {\n"                                                    );
        printf( "        result = Malloc( len );\n"                          );
        printf( "    }\n"                                                    );
        printf( "    else\n"                                                 );
        printf( "    {\n"                                                    );
        printf( "        result = Malloc( ENEW_LENGTH );\n"                  );
        printf( "        ENEW_LENGTH = -1;\n"                                );
        printf( "    }\n"                                                    );
        printf( "return result;\n"                                           );
        printf( "} // PNEW\n"                                                );
        seenENEW = TRUE;
    } # if ! seenENEW && ENEW != "N"

} # ENEW_LENGTH
